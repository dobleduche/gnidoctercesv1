import { promises as fs } from 'fs';
import path from 'path';
import { RefinedPrompt } from '../../types';
import { exec } from 'child_process';
import util from 'util';
import process from 'process';

const execPromise = util.promisify(exec);

const generateProjectId = () => `proj_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

const fileTemplates = {
  '.gitignore': `
# Dependencies
/node_modules
/client/node_modules

# Build output
/client/dist

# Env files
.env
.env.*
!.env.sample

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
`,
  'package.json': (name: string) => `{
  "name": "${name}",
  "version": "1.0.0",
  "description": "Generated by gnidoC terceS",
  "main": "server/index.js",
  "scripts": {
    "start": "node server/index.js",
    "dev": "concurrently \\"npm:dev:server\\" \\"npm:dev:client\\"",
    "dev:server": "nodemon server/index.js",
    "dev:client": "cd client && npm run dev",
    "build": "cd client && npm install && npm run build",
    "install:all": "npm install && cd client && npm install"
  },
  "dependencies": {
    "express": "^4.19.2",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5"
  },
  "devDependencies": {
    "concurrently": "^8.2.2",
    "nodemon": "^3.1.0"
  }
}`,

  '.env.sample': `PORT=3001

# AI Provider Keys
# Use API_KEY for Gemini, as per coding guidelines.
API_KEY=
OPENAI_API_KEY=
ANTHROPIC_API_KEY=
DEEPSEEK_API_KEY=
QWEN_API_KEY=
XAI_API_KEY=

# App Secrets
JWT_SECRET=dev_jwt_secret_change_me

# Stripe Keys
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=
STRIPE_PRICE_PRO=price_123
STRIPE_PRICE_PREMIUM=price_456
STRIPE_PRICE_ULT=price_789
`,

  'server/index.js': `require('dotenv').config();
const express = require('express');
const cors = require('cors');
const path = require('path');

const app = express();
app.use(cors());
app.use(express.json());

// API routes
app.get('/api/hello', (req, res) => {
  res.json({ message: 'Hello from the server!' });
});

app.post('/api/test', (req, res) => {
  const { name } = req.body;
  if (!name) {
    return res.status(400).json({ error: 'Name is required' });
  }
  res.json({ message: \`Hello, \${name}! Your full-stack smoke test was successful.\` });
});


// Serve static files from the React app
app.use(express.static(path.join(__dirname, '../client/dist')));

// The "catchall" handler: for any request that doesn't match one above,
// send back React's index.html file.
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../client/dist', 'index.html'));
});

const port = process.env.PORT || 3001;
app.listen(port, () => {
  console.log(\`Server listening on port \${port}\`);
});
`,

  'client/package.json': (name: string) => `{
  "name": "${name}-client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.0.3",
    "typescript": "^5.0.2",
    "vite": "^4.4.5",
    "tailwindcss": "^3.3.3",
    "postcss": "^8.4.27",
    "autoprefixer": "^10.4.14"
  }
}`,

  'client/vite.config.ts': `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': 'http://localhost:3001'
    }
  }
})`,
  'client/index.html': (name: string) => `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale-1.0" />
    <title>${name}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>`,

  'client/src/main.tsx': `import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
`,

  'client/src/App.tsx': (prompt: string) => `import { useState, useEffect, FormEvent } from 'react'

function App() {
  const [message, setMessage] = useState('');
  const [testName, setTestName] = useState('');
  const [testResponse, setTestResponse] = useState('');
  const [testLoading, setTestLoading] = useState(false);
  const [testError, setTestError] = useState('');
  
  useEffect(() => {
    fetch('/api/hello')
      .then(res => res.json())
      .then(data => setMessage(data.message))
      .catch(err => console.error(err));
  }, []);

  const handleSmokeTest = async (e: FormEvent) => {
    e.preventDefault();
    if (!testName) return;
    setTestLoading(true);
    setTestError('');
    setTestResponse('');
    try {
      const res = await fetch('/api/test', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: testName }),
      });
      const data = await res.json();
      if (!res.ok) {
        throw new Error(data.error || 'Something went wrong');
      }
      setTestResponse(data.message);
    } catch (err) {
      setTestError(err instanceof Error ? err.message : 'An unknown error occurred.');
    } finally {
      setTestLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4 font-sans">
      <div className="w-full max-w-3xl mx-auto text-center">
        <h1 className="text-4xl font-bold mb-4">Project Generated Successfully!</h1>
        <p className="text-lg mb-6 text-gray-300">This full-stack React application was generated based on your prompt:</p>
        <blockquote className="p-4 bg-gray-800 border-l-4 border-cyan-400 italic mb-8">
          ${prompt}
        </blockquote>
        
        <div className="space-y-8">
          <div className="p-6 rounded-lg bg-gray-800">
            <h2 className="text-xl font-semibold mb-2">Initial Server Check (GET)</h2>
            <p>Server says: <span className="font-mono p-2 bg-gray-700 rounded">{message || "Loading..."}</span></p>
          </div>

          <div className="p-6 rounded-lg bg-gray-800">
            <h2 className="text-xl font-semibold mb-4">Full-Stack Smoke Test (POST)</h2>
            <p className="text-sm text-gray-400 mb-4">Enter your name and submit to test the backend POST endpoint.</p>
            <form onSubmit={handleSmokeTest} className="flex flex-col sm:flex-row gap-2 justify-center">
              <input
                type="text"
                value={testName}
                onChange={(e) => setTestName(e.target.value)}
                placeholder="Enter your name"
                className="flex-grow px-4 py-2 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-cyan-400"
              />
              <button
                type="submit"
                disabled={!testName || testLoading}
                className="px-6 py-2 bg-cyan-500 text-gray-900 font-bold rounded-md hover:bg-cyan-400 transition-colors disabled:opacity-50 disabled:cursor-wait"
              >
                {testLoading ? 'Testing...' : 'Run Test'}
              </button>
            </form>
            <div className="mt-4 min-h-[50px] p-3 bg-gray-700 rounded text-left">
              <p className="text-sm text-gray-400 mb-1">Response:</p>
              {testLoading && <p className="text-gray-300 animate-pulse">Waiting for server...</p>}
              {testError && <p className="text-red-400 font-mono">{testError}</p>}
              {testResponse && <p className="text-green-400 font-mono">{testResponse}</p>}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

export default App
`,
  'client/src/index.css': `@tailwind base;
@tailwind components;
@tailwind utilities;
`,
  'client/tailwind.config.js': `/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}`,
  'client/postcss.config.js': `export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}`,
  'ci.yml': `name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build_and_test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [20.x]

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Use Node.js \${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: \${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'

    - name: Install server dependencies
      run: npm install

    - name: Build client application
      # The generated build script handles client dependency installation
      run: npm run build

    - name: Run tests (placeholder)
      run: echo "No tests configured. Add a 'test' script to your package.json."

  deploy:
    needs: build_and_test
    runs-on: ubuntu-latest
    # Only run on pushes to the main branch
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Deployment Placeholder
      run: |
        echo "Deployment step is a placeholder."
        echo "Configure your hosting provider's secrets (e.g., VERCEL_TOKEN) in your GitHub repository settings."
        echo "Then, add your deployment steps here. Example for Vercel:"
        echo "# - name: Deploy to Vercel"
        echo "#   uses: amondnet/vercel-action@v20"
        echo "#   with:"
        echo "#     vercel-token: \${{ secrets.VERCEL_TOKEN }}"
        echo "#     vercel-org-id: \${{ secrets.VERCEL_ORG_ID }}"
        echo "#     vercel-project-id: \${{ secrets.VERCEL_PROJECT_ID }}"
`,
};

export async function buildProject(
  engineered: RefinedPrompt
): Promise<{ projectId: string; projectDir: string }> {
  const projectId = generateProjectId();
  const projectDir = path.join(process.cwd(), 'generated', projectId);

  await fs.mkdir(projectDir, { recursive: true });

  const appName =
    engineered.goals[0]
      ?.split(' ')
      .slice(0, 3)
      .join('-')
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '') || 'my-awesome-app';

  // Create server files
  await fs.mkdir(path.join(projectDir, 'server'), { recursive: true });
  await fs.writeFile(path.join(projectDir, 'package.json'), fileTemplates['package.json'](appName));
  await fs.writeFile(path.join(projectDir, '.env.sample'), fileTemplates['.env.sample']);
  await fs.writeFile(path.join(projectDir, '.gitignore'), fileTemplates['.gitignore']);
  await fs.writeFile(path.join(projectDir, 'server/index.js'), fileTemplates['server/index.js']);

  // Create client files
  const clientDir = path.join(projectDir, 'client');
  const clientSrcDir = path.join(clientDir, 'src');
  await fs.mkdir(clientSrcDir, { recursive: true });
  await fs.writeFile(
    path.join(clientDir, 'package.json'),
    fileTemplates['client/package.json'](appName)
  );
  await fs.writeFile(
    path.join(clientDir, 'vite.config.ts'),
    fileTemplates['client/vite.config.ts']
  );
  await fs.writeFile(
    path.join(clientDir, 'index.html'),
    fileTemplates['client/index.html'](appName)
  );
  await fs.writeFile(
    path.join(clientDir, 'tailwind.config.js'),
    fileTemplates['client/tailwind.config.js']
  );
  await fs.writeFile(
    path.join(clientDir, 'postcss.config.js'),
    fileTemplates['client/postcss.config.js']
  );
  await fs.writeFile(path.join(clientSrcDir, 'main.tsx'), fileTemplates['client/main.tsx']);
  await fs.writeFile(
    path.join(clientSrcDir, 'App.tsx'),
    fileTemplates['client/src/App.tsx'](engineered.final_prompt)
  );
  await fs.writeFile(path.join(clientSrcDir, 'index.css'), fileTemplates['client/src/index.css']);

  // Create GitHub Actions workflow
  const workflowsDir = path.join(projectDir, '.github', 'workflows');
  await fs.mkdir(workflowsDir, { recursive: true });
  await fs.writeFile(path.join(workflowsDir, 'ci.yml'), fileTemplates['ci.yml']);

  try {
    console.log(`[${projectId}] Installing dependencies (this may take a few minutes)...`);
    await execPromise('npm install', { cwd: projectDir });
    await execPromise('npm install', { cwd: clientDir });

    console.log(`[${projectId}] Building client application...`);
    await execPromise('npm run build', { cwd: clientDir });
    console.log(`[${projectId}] Client build complete.`);
  } catch (error) {
    console.error(`[${projectId}] Project build failed:`, error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(
      `Project build failed. Please check server logs for project ID ${projectId}. Details: ${errorMessage}`
    );
  }

  return { projectId, projectDir: `/generated/${projectId}` };
}
